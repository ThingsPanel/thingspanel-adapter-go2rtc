# 协议插件架构设计 - 单协议专用方案

## 设计原则

- **极简优先** - 90%的协议只需要2个核心方法
- **单协议专用** - 一个中间件只支持一个协议，彻底简化架构
- **开箱即用** - 提供完整的开发模板和示例
- **完全通用** - 架构不绑定任何特定协议实现

## 重要概念区分

**设备编号 vs 设备ID**
- `device_number` - 设备本身的唯一标识符，从设备数据中提取
- `device_id` - 平台分配给设备的内部ID，用于平台内部标识

```
设备发送数据 → 提取device_number → 查询平台获取device_id → 发送到平台
```

## 核心设计思想：单协议专用

**一个中间件只支持一个协议**，彻底简化架构：

```
传感器协议中间件 → 端口15001 → 专门处理传感器协议
网关协议中间件   → 端口15002 → 专门处理网关协议  
表计协议中间件   → 端口15003 → 专门处理表计协议
```

## 整体架构

```
单协议中间件架构
├── cmd/main.go                     # 程序入口
├── internal/bootstrap/app.go       # 应用初始化
├── internal/platform/             # 平台通信
├── internal/handler/              # HTTP处理
└── internal/protocol/             # 协议开发区域
    ├── interface.go              # 协议接口定义
    ├── handler.go                # 单协议处理器
    ├── tcp_handler.go            # TCP连接处理器
    └── plugins/                  # 具体协议实现
        ├── my_protocol/          # 你的协议实现
        │   └── handler.go
        └── template/             # 协议开发模板
            └── simple/
                └── handler.go
```

## 协议接口设计

### 协议处理器接口

```go
// 协议处理器 - 简单清晰，90%的协议只需要实现这个接口
type ProtocolHandler interface {
    // 协议基本信息
    Name() string    // 协议名称
    Version() string // 协议版本
    Port() int       // 协议端口
    
    // 核心功能 - 只需要这三个方法！
    ExtractDeviceNumber(data []byte) (string, error) // 从数据包提取设备编号
    ParseData(data []byte) (*Message, error)         // 解析设备数据
    EncodeCommand(cmd *Command) ([]byte, error)      // 编码控制指令（可选）
    
    // 生命周期管理（通常只需要返回nil）
    Start() error // 启动协议
    Stop() error  // 停止协议
}
```

**就这么简单！** 大多数协议开发只需要关注这几个方法。

## 标准数据格式

### 消息格式

```go
// 设备数据消息
type Message struct {
    DeviceNumber string                 `json:"device_number"` // 设备编号(从设备中提取)
    DeviceID     string                 `json:"device_id"`     // 设备ID(平台分配的ID)
    MessageType  string                 `json:"message_type"`  // data/heartbeat/status
    Timestamp    time.Time              `json:"timestamp"`
    Data         map[string]interface{} `json:"data"`          // 设备数据
    Quality      int                    `json:"quality"`       // 数据质量，1=正常
}

// 设备指令
type Command struct {
    DeviceNumber string        `json:"device_number"` // 设备编号(从设备中提取)
    DeviceID     string        `json:"device_id"`     // 设备ID(平台分配的ID)
    CommandID    string        `json:"command_id"`
    Action       string        `json:"action"`              // sleep/config/query等
    Parameters   interface{}   `json:"parameters"`
    Timeout      time.Duration `json:"timeout"`
}
```

## TCP连接处理（框架提供，无需关心）

```go
// TCP处理器 - 框架提供，协议开发者无需关心
type TCPHandler struct {
    port         int
    handler      ProtocolHandler
    platform     *platform.PlatformClient
    logger       *logrus.Logger
    deviceCache  map[net.Conn]string // 连接到设备编号的映射
    mu           sync.RWMutex
    ctx          context.Context
    cancel       context.CancelFunc
}

// 协议处理逻辑 - 自动处理所有TCP连接细节
func (h *TCPHandler) handleConnection(conn net.Conn) {
    defer func() {
        h.notifyDeviceOffline(conn)
        conn.Close()
    }()
    
    // 设置连接超时
    conn.SetReadTimeout(30 * time.Second)
    
    buffer := make([]byte, 4096)
    var deviceNumber string
    deviceNumberExtracted := false
    
    for {
        n, err := conn.Read(buffer)
        if err != nil {
            if err != io.EOF {
                h.logger.WithError(err).Error("读取连接数据失败")
            }
            break
        }
        
        data := buffer[:n]
        
        // 首次提取设备编号
        if !deviceNumberExtracted {
            extractedNumber, err := h.handler.ExtractDeviceNumber(data)
            if err != nil {
                h.logger.WithError(err).Error("提取设备编号失败")
                continue
            }
            deviceNumber = extractedNumber
            deviceNumberExtracted = true
            
            // 缓存设备编号并发送上线通知
            h.mu.Lock()
            h.deviceCache[conn] = deviceNumber
            h.mu.Unlock()
            
            h.notifyDeviceOnline(conn, deviceNumber)
        }
        
        // 解析数据并发送到平台
        message, err := h.handler.ParseData(data)
        if err != nil {
            h.logger.WithError(err).Error("解析数据失败")
            continue
        }
        
        // 确保消息包含正确的设备信息
        if message.DeviceNumber == "" {
            message.DeviceNumber = deviceNumber
        }
        
        // 自动发送到ThingsPanel平台
        if err := h.sendToPlatform(message); err != nil {
            h.logger.WithError(err).Error("发送数据到平台失败")
        }
    }
}
```

## 单协议处理器（框架提供）

```go
// SingleProtocolHandler 单协议处理器
type SingleProtocolHandler struct {
    handler    ProtocolHandler
    tcpHandler *TCPHandler
    platform   PlatformInterface
    logger     *logrus.Logger
}

// 创建和启动单协议处理器
func NewSingleProtocolHandler(handler ProtocolHandler, platform PlatformInterface, logger *logrus.Logger) *SingleProtocolHandler {
    return &SingleProtocolHandler{
        handler:  handler,
        platform: platform,
        logger:   logger,
    }
}

// 启动协议处理器
func (s *SingleProtocolHandler) Start() error {
    // 启动协议
    if err := s.handler.Start(); err != nil {
        return fmt.Errorf("启动协议 %s 失败: %w", s.handler.Name(), err)
    }
    
    // 创建并启动TCP处理器
    s.tcpHandler = NewTCPHandler(s.handler.Port(), s.handler, s.platform, s.logger)
    if err := s.tcpHandler.Start(); err != nil {
        s.handler.Stop()
        return fmt.Errorf("启动TCP服务器失败: %w", err)
    }
    
    s.logger.Infof("协议 %s (v%s) 已启动，端口: %d", s.handler.Name(), s.handler.Version(), s.handler.Port())
    return nil
}
```

## 协议开发指南

### 开发步骤

**只需要4个步骤即可完成协议开发：**

1. **复制模板**
   ```bash
   cp -r internal/protocol/plugins/template/simple internal/protocol/plugins/my_protocol
   ```

2. **修改基本信息**
   ```go
   func (h *MyProtocolHandler) Name() string { return "MyProtocol" }
   func (h *MyProtocolHandler) Version() string { return "1.0.0" }
   func (h *MyProtocolHandler) Port() int { return h.port }
   ```

3. **实现设备编号提取**（最重要！）
   ```go
   func (h *MyProtocolHandler) ExtractDeviceNumber(data []byte) (string, error) {
       // 根据你的协议格式提取设备编号
       if len(data) < 4 {
           return "", errors.New("数据包太短")
       }
       
       deviceNumber := binary.BigEndian.Uint32(data[0:4])
       return fmt.Sprintf("%d", deviceNumber), nil
   }
   ```

4. **实现数据解析**
   ```go
   func (h *MyProtocolHandler) ParseData(data []byte) (*Message, error) {
       // 解析你的协议数据
       deviceNumber, err := h.ExtractDeviceNumber(data)
       if err != nil {
           return nil, err
       }
       
       // 根据协议格式解析传感器数据
       sensorData := map[string]interface{}{
           "temperature": extractTemperature(data),
           "humidity":    extractHumidity(data),
           // ... 其他数据字段
       }
       
       return &Message{
           DeviceNumber: deviceNumber,
           MessageType:  "data",
           Timestamp:    time.Now(),
           Data:         sensorData,
           Quality:      1,
       }, nil
   }
   ```

5. **可选：实现指令编码**
   ```go
   func (h *MyProtocolHandler) EncodeCommand(cmd *Command) ([]byte, error) {
       // 如果设备不支持控制指令，返回错误即可
       return nil, errors.New("设备不支持控制指令")
       
       // 或者根据指令类型编码
       switch cmd.Action {
       case "sleep":
           return h.buildSleepCommand(cmd.DeviceNumber)
       default:
           return nil, fmt.Errorf("不支持的指令: %s", cmd.Action)
       }
   }
   ```

**就这么简单！** 90%的协议开发只需要上面这些代码。

## 配置设计

### 极简配置

```yaml
# 单协议配置 - 只需要一个端口
server:
  port: 15001             # 协议服务端口
  http_port: 15002        # HTTP管理端口

platform:
  url: "http://thingspanel.com"
  mqtt_broker: "mqtt://broker.com:1883" 
  mqtt_username: "user"
  mqtt_password: "pass"
  service_identifier: "MyProtocol-v1.0"  # 协议服务标识符

log:
  level: "info"
  enableFile: true
```

### 初始化流程

在`internal/bootstrap/app.go`中：

```go
func initializeProtocol(app *AppContext, cfg *config.Config) error {
    // 创建你的协议处理器
    protocolHandler := my_protocol.NewHandler(cfg.Server.Port)
    
    // 创建单协议处理器
    singleHandler := protocol.NewSingleProtocolHandler(
        protocolHandler, 
        app.PlatformClient, 
        logrus.StandardLogger(),
    )
    
    // 启动协议
    if err := singleHandler.Start(); err != nil {
        return fmt.Errorf("启动协议失败: %w", err)
    }
    
    app.ProtocolHandler = singleHandler
    return nil
}
```

## 设备上下线机制

### 自动上下线检测

框架自动处理设备上下线：

1. **设备上线**：收到首个数据包并成功提取设备编号后发送上线状态
2. **设备下线**：TCP连接断开时自动发送下线状态
3. **平台通知**：通过`SendDeviceStatus`方法发送设备状态到ThingsPanel平台
4. **连接缓存**：维护连接到设备编号的映射，确保下线通知的准确性

### 平台接口

```go
// 发送设备状态
func (c *PlatformClient) SendDeviceStatus(deviceID string, status int) error {
    // status: 0=离线，1=在线
    // 发送设备状态到ThingsPanel平台
}

// 通过设备编号获取设备信息
func (c *PlatformClient) GetDevice(deviceNumber string) (*Device, error) {
    // 从平台获取设备完整信息
}
```

## 部署方案

### 单容器部署（推荐）

```yaml
# docker-compose.yml
version: "3.9"

services:
  my-protocol-middleware:
    image: my-protocol-middleware:1.0.0
    container_name: my-protocol-middleware
    ports:
      - "15001:15001"  # 协议端口
      - "15002:15002"  # HTTP管理端口
    environment:
      - "P_PLATFORM_URL=http://thingspanel:9999"
      - "P_PLATFORM_MQTT_BROKER=mqtt://mqtt-broker:1883"
      - "P_PLATFORM_SERVICE_IDENTIFIER=MyProtocol-v1.0"
    restart: unless-stopped
```

### 多协议需求

需要支持多个协议时，部署多个独立的中间件实例：

```yaml
version: "3.9"

services:
  sensor-protocol:
    image: sensor-protocol-middleware:1.0.0
    ports: ["15001:15001"]
    environment:
      - "P_PLATFORM_SERVICE_IDENTIFIER=SensorProtocol-v1.0"
      
  gateway-protocol:
    image: gateway-protocol-middleware:1.0.0 
    ports: ["15002:15001"]
    environment:
      - "P_PLATFORM_SERVICE_IDENTIFIER=GatewayProtocol-v1.0"
```

## 设计优势

### 1. **极致简化**
- ✅ 只需要实现3个核心方法
- ✅ 配置只需要一个端口
- ✅ 无需协议管理、注册、路由
- ✅ 调试简单，问题隔离性好

### 2. **开发友好**
- ✅ 模板驱动开发，复制即用
- ✅ 专注业务逻辑，无需关心基础设施
- ✅ 完整的开发指南和示例
- ✅ 自动处理设备上下线

### 3. **运维友好**
- ✅ 容器化部署，一个协议一个容器
- ✅ 独立升级，互不影响
- ✅ 精确的资源控制和监控
- ✅ 故障隔离性好

### 4. **平台集成**
- ✅ 自动数据转发到ThingsPanel
- ✅ 统一的心跳和状态管理
- ✅ 简化的MQTT主题结构
- ✅ 专用的HTTP管理接口

## 常见问题

### Q: 为什么选择单协议方案？
**A: 彻底简化！** 避免了协议管理、端口冲突、路由复杂性等问题，让开发专注于业务逻辑。

### Q: 需要多个协议怎么办？
**A: 部署多个实例！** 每个协议一个独立的中间件实例，容器化部署，互不影响。

### Q: 设备编号提取失败怎么办？
**A: 重试机制！** 框架会持续尝试从后续数据包中提取设备编号，直到成功或连接断开。

### Q: 如何处理协议升级？
**A: 独立升级！** 每个协议中间件独立部署，可以单独升级，不影响其他协议。

### Q: 资源消耗会增加吗？
**A: 增加有限！** 每个Go程序的基础内存消耗很小（<10MB），相比简化的开发和运维成本，这个代价微不足道。

## 总结

这个架构的核心思想是：**一个中间件只做一件事，并且做好这件事**

- ✅ **单协议专用**：彻底避免多协议复杂性
- ✅ **极简开发**：只需要关注3个核心方法
- ✅ **极简配置**：只需要一个端口配置
- ✅ **极简部署**：容器化部署，一个协议一个容器
- ✅ **极简运维**：独立升级，精确监控，故障隔离

**对于IoT协议开发，你现在只需要专注于数据解析逻辑，其他一切都极其简单。**
