# 协议插件架构设计 - 通用端口隔离方案

## 设计原则

- **极简优先** - 90%的协议只需要2个核心方法
- **端口隔离** - 每个协议使用独立端口，避免协议识别问题
- **渐进增强** - 简单协议保持简单，复杂需求可选扩展
- **完全通用** - 架构不绑定任何特定协议实现

## 重要概念区分

**设备编号 vs 设备ID**
- `device_number` - 设备本身的唯一标识符，从设备数据中提取
- `device_id` - 平台分配给设备的内部ID，用于平台内部标识

```
设备发送数据 → 提取device_number → 查询平台获取device_id → 发送到平台
```

## 核心设计思想：端口隔离

**每个协议使用独立端口**，避免协议识别的复杂性：

```
简单协议设备 → 端口15001 → 简单协议处理器
复杂协议设备 → 端口15002 → 复杂协议处理器  
其他协议设备 → 端口15003 → 其他协议处理器
```

## 整体架构

```
现有框架保持不变
├── cmd/main.go                     # 程序入口（不变）
├── internal/bootstrap/app.go       # 应用初始化（不变）
├── internal/platform/             # 平台通信（不变）
├── internal/handler/              # HTTP处理（不变）
└── internal/protocol/             # 协议开发区域
    ├── interface.go              # 协议接口定义
    ├── manager.go                # 协议管理器
    ├── tcp_handler.go            # TCP连接处理基础组件
    └── plugins/                  # 具体协议实现
        ├── simple_protocol/      # 简单协议示例
        │   └── handler.go
        ├── complex_protocol/     # 复杂协议示例
        │   └── handler.go
        └── template/             # 协议模板
            ├── simple/
            └── complex/
```

## 协议接口设计

### 基础协议接口（90%的协议只需要这个）

```go
// 基础协议处理器 - 适用于无状态、简单数据交互的协议
type ProtocolHandler interface {
    // 协议基本信息
    Name() string
    Version() string
    Port() int                                   // 协议专用端口
    
    // 核心功能 - 只需要这两个方法！
    ParseData(data []byte) (*Message, error)     // 解析设备数据
    EncodeCommand(cmd *Command) ([]byte, error)  // 编码控制指令
    
    // 设备编号提取（从数据包中提取设备编号，注意：不是平台的device_id）
    ExtractDeviceNumber(data []byte) (string, error) // 从数据包提取设备编号
    
    // 生命周期管理（通常只需要返回nil）
    Start() error                                // 启动协议
    Stop() error                                 // 停止协议
}
```

### 可选：增强协议接口（只有复杂协议才需要）

```go
// 增强协议处理器 - 适用于有状态、多消息类型的复杂协议
type EnhancedProtocolHandler interface {
    ProtocolHandler  // 嵌入基础接口
    
    // 自定义连接处理（替代默认的简单处理逻辑）
    HandleConnection(conn net.Conn) error        // 处理完整连接生命周期
    
    // 连接事件处理（可选实现）
    OnConnectionEstablished(conn net.Conn) error // 连接建立时调用
    OnConnectionClosed(conn net.Conn) error      // 连接关闭时调用
}
```

**注意**：99%的情况下，你不需要`EnhancedProtocolHandler`！

## 标准数据格式

### 消息格式

```go
// 设备数据消息
type Message struct {
    DeviceID    string                 `json:"device_id"`
    MessageType string                 `json:"message_type"`  // data/heartbeat/status
    Timestamp   time.Time              `json:"timestamp"`
    Data        map[string]interface{} `json:"data"`          // 设备数据
    Quality     int                    `json:"quality"`       // 数据质量，1=正常
}

// 设备指令
type Command struct {
    DeviceID   string        `json:"device_id"`
    CommandID  string        `json:"command_id"`
    Action     string        `json:"action"`              // sleep/config/query等
    Parameters interface{}   `json:"parameters"`
    Timeout    time.Duration `json:"timeout"`
}
```

## TCP连接处理（框架提供，无需关心）

```go
// TCP处理器 - 框架提供，协议开发者无需关心
type TCPHandler struct {
    port         int
    handler      ProtocolHandler
    platform     *platform.PlatformClient
    logger       *logrus.Logger
    deviceCache  map[net.Conn]string // 连接到设备ID的映射
    mu           sync.RWMutex
    ctx          context.Context
    cancel       context.CancelFunc
}

// 简单协议的默认处理逻辑
func (h *TCPHandler) handleSimpleProtocol(conn net.Conn) {
    defer func() {
        h.notifyDeviceOffline(conn)
        conn.Close()
    }()
    
    // 设置连接超时
    conn.SetReadTimeout(30 * time.Second)
    
    buffer := make([]byte, 4096)
    var deviceID string
    deviceIDExtracted := false
    
    for {
        n, err := conn.Read(buffer)
        if err != nil {
            if err != io.EOF {
                h.logger.WithError(err).Error("读取连接数据失败")
            }
            break
        }
        
        data := buffer[:n]
        
        // 首次提取设备ID
        if !deviceIDExtracted {
            extractedID, err := h.handler.ExtractDeviceNumber(data)
            if err != nil {
                h.logger.WithError(err).Error("提取设备ID失败")
                continue
            }
            deviceID = extractedID
            deviceIDExtracted = true
            
            // 缓存设备ID
            h.mu.Lock()
            h.deviceCache[conn] = deviceID
            h.mu.Unlock()
            
            // 发送设备上线通知
            h.notifyDeviceOnline(conn, deviceID)
        }
        
        // 调用协议的ParseData方法
        message, err := h.handler.ParseData(data)
        if err != nil {
            h.logger.WithError(err).Error("解析数据失败")
            continue
        }
        
        // 自动发送到ThingsPanel平台
        if err := h.sendToPlatform(message); err != nil {
            h.logger.WithError(err).Error("发送数据到平台失败")
        }
    }
}

// 设备上线通知
func (h *TCPHandler) notifyDeviceOnline(conn net.Conn, deviceID string) {
    // 发送设备上线状态
    if err := h.platform.SendDeviceStatus(deviceID, 1); err != nil {
        h.logger.WithError(err).Error("发送设备上线状态失败")
    } else {
        h.logger.Infof("设备上线: %s (%s)", deviceID, conn.RemoteAddr())
    }
}

// 设备下线通知  
func (h *TCPHandler) notifyDeviceOffline(conn net.Conn) {
    h.mu.RLock()
    deviceID, exists := h.deviceCache[conn]
    h.mu.RUnlock()
    
    if !exists {
        return // 设备ID未提取，无需发送下线通知
    }
    
    // 清理缓存
    h.mu.Lock()
    delete(h.deviceCache, conn)
    h.mu.Unlock()
    
    // 发送设备下线状态
    if err := h.platform.SendDeviceStatus(deviceID, 0); err != nil {
        h.logger.WithError(err).Error("发送设备下线状态失败")
    } else {
        h.logger.Infof("设备下线: %s (%s)", deviceID, conn.RemoteAddr())
    }
}

// 发送数据到平台
func (h *TCPHandler) sendToPlatform(message *Message) error {
    // 适配现有平台接口
    return h.platform.SendTelemetry(message.DeviceID, message.Data)
}

// 优雅停止
func (h *TCPHandler) Stop() error {
    h.cancel()
    if h.listener != nil {
        return h.listener.Close()
    }
    return nil
}
```

## 协议管理器（框架提供）

```go
type ProtocolManager struct {
    protocols   map[string]ProtocolHandler
    tcpHandlers map[string]*TCPHandler
    platform    *platform.PlatformClient
    logger      *logrus.Logger
}

// 注册协议 - 框架自动处理TCP服务器创建和生命周期管理
func (m *ProtocolManager) RegisterProtocol(handler ProtocolHandler) error {
    name := handler.Name()
    port := handler.Port()
    
    // 检查端口冲突
    // 创建TCP服务器
    // 启动监听
    // 注册到管理器
    // ...
}

// 获取所有已注册协议信息
func (m *ProtocolManager) GetProtocolInfo() []ProtocolInfo {
    // 返回协议列表、端口、状态等信息
}

// 停止所有协议
func (m *ProtocolManager) StopAll() error {
    // 优雅停止所有协议和TCP服务器
}
```

## 开发指南

### 简单协议开发（95%的情况）

适用于：传感器数据采集、简单设备控制等无状态协议

```go
// 简单协议处理器
type SimpleProtocolHandler struct {
    port int
}

func NewSimpleProtocolHandler(port int) *SimpleProtocolHandler {
    return &SimpleProtocolHandler{port: port}
}

// 1. 基本信息
func (h *SimpleProtocolHandler) Name() string { return "SimpleProtocol" }
func (h *SimpleProtocolHandler) Version() string { return "1.0.0" }
func (h *SimpleProtocolHandler) Port() int { return h.port }

// 2. 核心方法1：解析数据（重点！）
func (h *SimpleProtocolHandler) ParseData(data []byte) (*Message, error) {
    // 1. 验证数据格式
    if len(data) < 6 {
        return nil, errors.New("数据包太短")
    }
    
    // 2. 解析设备ID（根据你的协议格式）
    deviceID, err := h.ExtractDeviceNumber(data)
    if err != nil {
        return nil, fmt.Errorf("解析设备ID失败: %w", err)
    }
    
    // 3. 解析传感器数据（根据你的协议格式）
    sensorData := map[string]interface{}{
        "temperature": extractTemperature(data),
        "humidity":    extractHumidity(data),
        "voltage":     extractVoltage(data),
        // ... 其他数据字段
    }
    
    return &Message{
        DeviceID:    deviceID,
        MessageType: "data",
        Timestamp:   time.Now(),
        Data:        sensorData,
        Quality:     1,
    }, nil
}

// 3. 核心方法2：编码指令（如果设备需要指令）
func (h *SimpleProtocolHandler) EncodeCommand(cmd *Command) ([]byte, error) {
    switch cmd.Action {
    case "sleep":
        // 返回休眠指令包
        return buildSleepCommand(cmd.DeviceID, cmd.Parameters)
    case "config":
        // 返回配置指令包
        return buildConfigCommand(cmd.DeviceID, cmd.Parameters)
    default:
        return nil, fmt.Errorf("不支持的指令: %s", cmd.Action)
    }
}

// 4. 设备编号提取（重点！）
func (h *SimpleProtocolHandler) ExtractDeviceNumber(data []byte) (string, error) {
    // 根据你的协议格式提取设备编号
    // 例如：设备编号在数据包的第1-4字节
    if len(data) < 4 {
        return "", errors.New("数据包太短，无法提取设备编号")
    }
    
    // 示例：从固定位置提取设备编号
    deviceID := binary.LittleEndian.Uint32(data[0:4])
    return fmt.Sprintf("%d", deviceID), nil
}

// 5. 生命周期（通常只需要打印日志）
func (h *SimpleProtocolHandler) Start() error {
    logrus.Infof("简单协议启动，端口: %d", h.port)
    return nil
}

func (h *SimpleProtocolHandler) Stop() error {
    logrus.Info("简单协议停止")
    return nil
}
```

**就这么简单！** 90%的协议开发只需要上面这些代码。

### 复杂协议开发（5%的情况）

适用于：网关协议、多消息类型、有状态协议

```go
type ComplexProtocolHandler struct {
    *SimpleProtocolHandler  // 继承简单协议
    sessions map[string]*Session
    mu       sync.RWMutex
}

// 实现增强接口，自定义连接处理
func (h *ComplexProtocolHandler) HandleConnection(conn net.Conn) error {
    // 复杂的连接处理逻辑
    // 1. 处理认证/握手
    // 2. 消息类型路由
    // 3. 状态管理
    // 4. 心跳处理
    // ...
}

func (h *ComplexProtocolHandler) OnConnectionEstablished(conn net.Conn) error {
    // 连接建立时的特殊处理
    return nil
}

func (h *ComplexProtocolHandler) OnConnectionClosed(conn net.Conn) error {
    // 连接关闭时的清理工作
    return nil
}
```

## 配置设计

```yaml
# 协议配置 - 极简配置
protocols:
  simple_protocol:
    enabled: true
    port: 15001        # 协议专用端口
    
  complex_protocol:
    enabled: true  
    port: 15002        # 协议专用端口
    
  another_protocol:
    enabled: true
    port: 15003
```

## 注册流程

在`internal/bootstrap/app.go`中：

```go
func initializeProtocols(app *AppContext, cfg *config.Config) error {
    manager := protocol.NewManager(app.PlatformClient, logrus.StandardLogger())
    
    // 注册协议 - 只需要一行代码！
    if cfg.Protocols.SimpleProtocol.Enabled {
        handler := simple_protocol.NewHandler(cfg.Protocols.SimpleProtocol.Port)
        manager.RegisterProtocol(handler)
    }
    
    if cfg.Protocols.ComplexProtocol.Enabled {
        handler := complex_protocol.NewHandler(cfg.Protocols.ComplexProtocol.Port)
        manager.RegisterProtocol(handler)
    }
    
    app.ProtocolManager = manager
    return nil
}
```

## 设备上下线机制

### 自动上下线检测

框架自动处理设备上下线：

1. **设备上线**：收到首个数据包并成功提取设备编号后发送上线状态
2. **设备下线**：TCP连接断开时自动发送下线状态
3. **平台通知**：通过SendDeviceStatus方法发送设备状态到ThingsPanel平台
4. **连接缓存**：维护连接到设备编号的映射，确保下线通知的准确性

### 平台接口

在`platform.PlatformClient`中已提供设备状态接口：

```go
// 发送设备状态
func (c *PlatformClient) SendDeviceStatus(deviceID string, status int) error {
    // status: 0=离线，1=在线
    // 发送设备状态到ThingsPanel平台
}
```

### 错误处理和资源管理

1. **连接超时**：设置读取超时，防止连接长时间无响应
2. **设备编号缓存**：使用线程安全的map缓存连接与设备编号的映射
3. **优雅停止**：支持context取消，优雅关闭所有连接
4. **错误日志**：详细记录设备上下线和数据处理错误

## 设计优势

1. **极其简单** - 90%的协议只需要实现2个方法
2. **完全通用** - 不绑定任何特定协议
3. **端口隔离** - 避免所有识别复杂性
4. **自动上下线** - 框架自动处理设备状态通知
5. **渐进增强** - 简单协议保持简单，复杂需求可扩展
6. **故障隔离** - 协议独立运行，互不影响

## 常见问题

### Q: 什么时候使用简单协议接口？
**A: 95%的情况！** 适用于传感器数据采集、设备控制等无状态协议。

### Q: 什么时候需要增强协议接口？
**A: 很少需要！** 只有当协议需要处理多种消息类型、维护连接状态时才需要。

### Q: 设备上下线如何通知？
**A: 自动处理！** 框架在收到首个数据包提取设备编号后发送上线状态，连接断开时发送下线状态。

### Q: 如何处理端口冲突？
**A: 配置隔离！** 每个协议使用独立端口，在配置文件中明确指定。

### Q: 设备编号提取失败怎么办？
**A: 重试机制！** 框架会持续尝试从后续数据包中提取设备编号，直到成功或连接断开。

### Q: 如何处理连接异常？
**A: 自动恢复！** 框架设置连接超时，异常连接会自动断开并发送下线状态。

## 总结

这个架构的核心思想是：**让简单的事情保持简单，让复杂的事情成为可能**

- ✅ **简单协议**：只需要2个方法，10分钟上手
- ✅ **复杂协议**：完整的连接控制和状态管理
- ✅ **端口隔离**：避免所有识别复杂性
- ✅ **自动监控**：设备上下线自动通知平台
- ✅ **完全通用**：适配任何IoT协议

**对于大多数IoT协议开发，你只需要关注数据解析逻辑，其他一切都由框架自动处理。**
